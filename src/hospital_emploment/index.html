<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Employment Map Visualization</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        .country {
            stroke: #fff;
            stroke-width: 0.3;
            cursor: pointer;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
        h2 {
            text-align: center;
            font-size: 24px;
            margin-top: 20px;
        }
        #container {
            display: flex;
        }
        #legend {
            margin-left: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
        }
    </style>
</head>
<body>

<h2>Hospital Employment Across Countries</h2>

<div id="globe"></div>

<div id="container">
    <div id="chart"></div> <!-- Div để hiển thị biểu đồ cột chồng -->
    <div id="legend"></div> <!-- Div để hiển thị hướng dẫn -->
</div>

<script>
    const width = 960, height = 600;
    const svg = d3.select("#globe").append("svg")
        .attr("width", width)
        .attr("height", height);

    const projection = d3.geoEquirectangular()
        .scale(160)
        .translate([width / 2, height / 2]);

    const path = d3.geoPath().projection(projection);

    const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    Promise.all([
        d3.json("../map.json").catch(error => console.error("GeoJSON file not found:", error)), 
        d3.csv("../../data/result/hospital_employment.csv").catch(error => console.error("CSV file not found:", error))
    ]).then(([geoData, csvData]) => {
        if (!geoData || !csvData) {
            console.error("Data loading failed.");
            return;
        }

        const data = {};
        csvData.forEach(d => {
            if(d.Measure == "Number of persons (head counts)"){
                if (!data[d.COU]) data[d.COU] = [];
                data[d.COU].push({ year: d.TIME_PERIOD, value: +d.Value, variable: d.Variable });
            }
        });

        const colorScale = d3.scalePow()
            .exponent(0.4)
            .domain([0, d3.max(csvData, d => +d.Value)])
            .range(["#fdae61", "#d7191c"]);

        svg.selectAll("path")
            .data(geoData.features)
            .enter().append("path")
            .attr("class", "country")
            .attr("fill", d => {
                const value = data[d.properties.iso_a3] ? data[d.properties.iso_a3][0].value : null;
                return value ? colorScale(value) : "#ccc";
            })
            .attr("d", path)
            .on("mouseover", (event, d) => {
                const countryData = data[d.properties.iso_a3];
                const value = countryData ? countryData.reduce((acc, curr) => acc + curr.value, 0) : "N/A";
                const formattedValue = value !== "N/A" ? value.toFixed(2) : value;
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`<strong>${d.properties.name}</strong><br>Employment: ${formattedValue}`)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
            })
            .on("click", (event, d) => {
                const countryData = data[d.properties.iso_a3];
                if (countryData) {
                    showStackedBarChart(d.properties.name, countryData);
                }
            });

        function showStackedBarChart(countryName, countryData) {
            // Clear previous chart and legend
            d3.select("#chart").html("");
            d3.select("#legend").html("");

            const margin = {top: 20, right: 30, bottom: 40, left: 60},
                  chartWidth = 500 - margin.left - margin.right,
                  chartHeight = 300 - margin.top - margin.bottom;

            const svg = d3.select("#chart").append("svg")
                .attr("width", chartWidth + margin.left + margin.right)
                .attr("height", chartHeight + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Group data by year and stack by variable
            const years = Array.from(new Set(countryData.map(d => d.year)));
            const variables = Array.from(new Set(countryData.map(d => d.variable)));

            // const stackedData = d3.stack()
            //     .keys(variables)
            //     .value((d, key) => d[key] || 0)(
            //         d3.rollups(countryData, v => Object.fromEntries(v.map(d => [d.variable, d.value])), d => d.year, d => d.key)
            //             .map(([year, values, key]) => ({ year, ...values ,key}))
            //     );

            console.log(countryData);
            const stackedData = years.map(d => {return {year: d, data: countryData.filter(k => k.year == d)}}).sort((a,b) => a.year - b.year)
            
            const categories = stackedData.map(d => d.key);
                
            console.log(stackedData);

            const x = d3.scaleBand()
                .domain(stackedData.map(d => d.year))
                .range([0, chartWidth])
                .padding(0.2);

            const y = d3.scaleLinear()
                .domain([0, d3.max(stackedData, d => d3.max(d.data, k => k.value))])
                .nice()
                .range([chartHeight, 0]);

            const color = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(variables);

            // Add bars
            svg.append("g")
                .selectAll("g")
                .data(stackedData)
                .enter().append("g")
                .selectAll("rect")
                .data(k => k.data)
                .enter().append("rect")
                .attr("x", k => {
                    console.log(k)
                    return x(k.year) + variables.indexOf(k.variable) * x.bandwidth()/stackedData[0].data.length
                })
                .attr("y", k => y(k.value))
                .attr("height", k => chartHeight -y(k.value))
                .attr("width", x.bandwidth()/stackedData[0].data.length)
                .attr("fill", d => color(d.variable));

            svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x));

            svg.append("g")
                .attr("class", "y-axis")
                .call(d3.axisLeft(y));

            svg.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", 0 - margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text(`Employment in ${countryName} Over Time`);

            // Create Legend
            const legend = d3.select("#legend")
                .append("div")
                .attr("class", "legend");

            variables.forEach(variable => {
                const legendItem = legend.append("div")
                    .attr("class", "legend-item");

                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", color(variable));

                legendItem.append("div")
                    .text(variable); // Display variable name
            });
        }
    }).catch(error => {
        console.error('Error loading or parsing data:', error);
    });
</script>
</body>
</html>
